================================================================================
EXPLICAÇÃO PASSO-A-PASSO COMPLETA (C1 / S / C2) + BACKDOORS
================================================================================

Notação:
  C1 = cliente 1 (Alice)
  C2 = cliente 2 (Bob)
  S  = servidor (malicioso / com backdoors)

Comandos:
  /register     -> criar utilizador + enviar chaves públicas (RSA + Schnorr)
  /login        -> provar conhecimento da password via Schnorr ZKP
  /dh_start     -> criar sessão DH para cifra simétrica
  /send         -> mensagem cifrada (AES-CBC + HMAC) mas com backdoor via blob
  /send_signed  -> mensagem cifrada + assinada, mas as assinaturas também são subvertidas

Vamos seguir pela ordem lógica em que as coisas aparecem no teu código.

--------------------------------------------------------------------------------
1. FASE DE REGISTO (/register)
--------------------------------------------------------------------------------

(1.1) C1 gera chaves RSA localmente
-----------------------------------
C1 gera localmente um par de chaves RSA:

  sk_Alice_real, pk_Alice_real = RSA.generate()

Isto existe apenas em C1:
  - sk_Alice_real (privada) é encriptada em disco com a password.
  - pk_Alice_real (pública) fica em texto claro em alice_pub.pem.

(1.2) C1 deriva o segredo Schnorr x
-----------------------------------
C1 deriva um segredo Schnorr a partir de username + password:

  username_norm = lower(username)
  x = H(username_norm || ":" || password) mod Q_SCHNORR

Depois calcula a chave pública Schnorr:

  y = g^x mod p

(1.3) C1 envia dados de registo para S
--------------------------------------
C1 -> S envia:

  REGISTER username password pk_Alice_real_DER_base64 y_base64

S recebe:
  - username
  - password (que nesta versão final nem é usada para auth clássica)
  - pk_Alice_real (a verdadeira chave pública RSA do cliente)
  - y (chave pública Schnorr para login ZKP futuro)

(1.4) S guarda utilizador + chave Schnorr na BD
-----------------------------------------------
S guarda na base de dados:

  - tabela users:
      username (lowercase)
      pubkey_b64 = pk_Alice_real_DER_base64

  - tabela schnorr_users:
      username (lowercase)
      y_b64 = chave pública Schnorr y (em base64)

S também carrega pk_Alice_real para memória:
  users[username] = pk_Alice_real_object


(1.5) S cria um par de chaves de "impersonação" para este utilizador
--------------------------------------------------------------------
Aqui está o "primeiro grande backdoor":

Para cada utilizador registado, S gera o seu próprio par de chaves RSA:

  sk_Server_as_Alice, pk_Server_as_Alice = RSA.generate()

e guarda:

  impersonation_keys["alice"] = sk_Server_as_Alice

Esta chave privada só é conhecida pelo servidor.

Isto significa:
  - O servidor consegue produzir assinaturas que parecem vir da "Alice",
    desde que os clientes usem mais tarde pk_Server_as_Alice para verificar.

S -> C1 responde:

  OK REGISTER


--------------------------------------------------------------------------------
2. FASE DE LOGIN (/login via Schnorr ZKP)
--------------------------------------------------------------------------------

(2.1) C1 calcula r e t para Schnorr
-----------------------------------
C1 volta a derivar:

  x = H(username_norm || ":" || password) mod Q

Depois escolhe r aleatório:

  r aleatório em [1, Q-1]
  t = g^r mod p

C1 -> S envia:

  LOGIN_ZKP username t_b64

(2.2) S obtém a chave Schnorr e envia desafio
---------------------------------------------
S faz:

  y_b64 = fetch_schnorr_pub(username)
  y_int = decode(y_b64)  # da BD

S gera um desafio aleatório c:

  c_int aleatório em [0, Q-1]
  (guarda (username, t, c, y) em pending_schnorr[conn])

S -> C1 envia:

  ZKP_CHALLENGE c_b64

(2.3) C1 calcula resposta s
---------------------------
C1 descodifica c e calcula:

  s = r + c * x mod Q

C1 -> S envia:

  LOGIN_ZKP_RESP username s_b64

(2.4) S verifica a prova Schnorr
--------------------------------
S vai buscar (username, t, c, y) de pending_schnorr.

Verifica:

  left  = g^s mod p
  right = t * y^c mod p

Se left == right:
  - ZKP tem sucesso
  - o utilizador fica autenticado
  - S marca current_username = username
  - S adiciona (username -> socket) em online_clients

S -> C1 envia:

  OK LOGIN_ZKP

Além disso:
  - C1 desencripta localmente a sua chave privada RSA com a password
    e guarda sk_Alice_real em memória para assinar mensagens.

Este login com ZKP garante:
  - S não aprende diretamente a password ou x (para além do que conseguir
    por brute-force),
  - Mas S continua a controlar o resto (distribuição de chaves, routing,
    backdoors, etc.).


--------------------------------------------------------------------------------
3. FASE DIFFIE-HELLMAN (/dh_start)
--------------------------------------------------------------------------------

(3.1) C1 inicia DH com C2
-------------------------
C1 gera um par de chaves X25519:

  dh_priv_Alice, dh_pub_Alice = X25519.generate()

C1 guarda:

  dh_sessions["bob"] = {
      "dh_priv": dh_priv_Alice,
      "shared": None,
      "k_enc": None,
      "k_mac": None
  }

C1 -> S envia:

  DH_INIT bob base64(dh_pub_Alice)

(3.2) S encaminha DH_INIT para C2
---------------------------------
S procura o dest "bob" em online_clients e depois:

S -> C2 envia:

  DH_INIT_FROM alice base64(dh_pub_Alice)

(3.3) C2 responde com a sua chave DH pública
--------------------------------------------
C2 ao receber DH_INIT_FROM:
  - gera dh_priv_Bob, dh_pub_Bob
  - calcula o segredo partilhado:

      shared_B = dh_priv_Bob.exchange(dh_pub_Alice)

  - deriva as chaves:

      K_enc = SHA256("enc" || shared)[0:16]
      K_mac = SHA256(K_enc)

  - guarda em dh_sessions["alice"]:
      {
        "dh_priv": dh_priv_Bob,
        "shared": shared_B,
        "k_enc": K_enc,
        "k_mac": K_mac
      }

C2 -> S envia:

  DH_REPLY alice base64(dh_pub_Bob)

(3.4) S encaminha DH_REPLY para C1
----------------------------------
S -> C1 envia:

  DH_REPLY_FROM bob base64(dh_pub_Bob)

C1 recebe e calcula:

  shared_A = dh_priv_Alice.exchange(dh_pub_Bob)

Depois deriva:

  K_enc = SHA256("enc" || shared_A)[0:16]
  K_mac = SHA256(K_enc)

Agora C1 e C2 partilham:
  - K_enc (chave AES)
  - K_mac (chave de HMAC)

MAS o passo seguinte é crucial: o "blob" backdoor permite ao servidor
recuperar K_enc.


--------------------------------------------------------------------------------
4. /send — MENSAGEM CIFRADA COM BACKDOOR VIA BLOB
--------------------------------------------------------------------------------

(4.1) C1 constrói o pacote cifrado
----------------------------------
Quando C1 faz:

  /send bob <mensagem>

O cliente faz:

  - header = "alice->bob".encode()
  - K_enc, K_mac vindos da sessão DH
  - blob = AES_ECB_Encrypt(K_SERVER, K_enc)    # BACKDOOR!
  - iv   = blob[0:16]                          # usa parte do blob como IV
  - cipher = AES_CBC_Encrypt(K_enc, iv, msg)
  - tag    = HMAC_SHA256(K_mac, header || blob || iv || cipher)

Depois C1 -> S envia:

  MSG bob base64(header) base64(blob) base64(iv) base64(cipher) base64(tag)

(4.2) S usa o blob para recuperar K_enc
---------------------------------------
O servidor recebe:

  (dest, header_b64, blob_b64, iv_b64, cipher_b64, tag_b64)

Descodifica header, blob, iv, cipher, tag.

Passo do backdoor:

  k_enc = AES_ECB_Decrypt(K_SERVER, blob)
  k_mac = SHA256(k_enc)

O servidor agora consegue:
  - Recalcular tag = HMAC_SHA256(k_mac, header || blob || iv || cipher)
  - Verificar integridade (HMAC)
  - Decifrar:

      plaintext = AES_CBC_Decrypt(k_enc, iv, cipher)

Ou seja, S vê todas as mensagens em claro.

(4.3) S pode modificar a mensagem
---------------------------------
O teu código faz algo do género:

  msg_mod = plaintext_str
  if msg_mod.startswith("!upper "):
      msg_mod = msg_mod[len("!upper ") :].upper()

Portanto, o servidor pode alterar o conteúdo antes de o entregar ao destinatário.
(Isto é só um demo; na realidade S podia fazer o que quisesse.)

Depois S recifra:

  plaintext_out = msg_mod.encode()
  cipher_out    = AES_CBC_Encrypt(k_enc, iv, plaintext_out)
  tag_out       = HMAC(k_mac, header || blob || iv || cipher_out)

S -> C2 envia:

  MSG_FROM alice base64(header) base64(blob) base64(iv)
           base64(cipher_out) base64(tag_out)

(4.4) C2 decifra e verifica
---------------------------
C2:
  - obtém K_enc, K_mac da sessão DH (com "alice")
  - recalcula tag_calc = HMAC(K_mac, header || blob || iv || cipher)
  - se tag_calc == tag: a mensagem é "autêntica" a nível simétrico
  - decifra com AES-CBC(K_enc, iv, cipher)
  - imprime o plaintext

Resultado:
  - C2 pensa que a mensagem é cifrada + autenticada end-to-end entre C1 e C2
  - Na realidade, S:
      * vê sempre o plaintext
      * pode modificar arbitrariamente
      * consegue recalcular HMAC válido (porque conhece K_enc e K_mac)

Este é o "blob backdoor" em /send.


--------------------------------------------------------------------------------
5. /send_signed — CIFRADA + ASSINADA, MAS O RSA TAMBÉM ESTÁ BACKDOORED
--------------------------------------------------------------------------------

Objetivo de /send_signed:
  - C1: assinar a mensagem com a sua chave privada RSA (sk_Alice_real)
  - C2: verificar com a chave pública da Alice
  - Simular autenticidade ponta-a-ponta

Num sistema seguro normal:
  - pk_Alice_real é distribuída de forma autêntica.
  - Ninguém além da Alice tem sk_Alice_real.
  - O servidor não consegue forjar assinaturas da Alice.

Mas aqui o servidor:
  - controla que chave pública C2 vê via /getpk
  - tem a sua própria chave privada sk_Server_as_Alice
  - volta a assinar mensagens com essa chave.

Vamos ver o fluxo.

(5.1) C1 assina e cifra a mensagem
----------------------------------
C1, quando fazes:

  /send_signed bob "minha mensagem"

O cliente faz:

  msg_bytes = b"minha mensagem"

  # 1. Assinar com a chave REAL da Alice
  sig_real = RSA_sign(sk_Alice_real, msg_bytes)

  b64_sig = base64(sig_real)

  # 2. Construir plaintext com assinatura embutida
  plaintext = "minha mensagem||SIG||" + b64_sig

Depois cifra exatamente como em /send:

  - header = "alice->bob"
  - blob   = AES_ECB(K_SERVER, K_enc)
  - iv     = blob[0:16]
  - cipher = AES_CBC(K_enc, iv, plaintext)
  - tag    = HMAC(K_mac, header || blob || iv || cipher)

C1 -> S envia:

  MSG bob header_b64 blob_b64 iv_b64 cipher_b64 tag_b64

(5.2) S lê e (se quiser) altera a mensagem assinada
---------------------------------------------------
S descodifica e usa o blob backdoor para obter K_enc, K_mac:

  k_enc = AES_ECB_Decrypt(K_SERVER, blob)
  k_mac = SHA256(k_enc)

Verifica o HMAC, decifra e obtém o plaintext:

  plaintext = "minha mensagem||SIG||<base64(sig_real)>"

Agora entra o "RSA backdoor":

O teu código verifica se "||SIG||" está em msg_mod. Se estiver:

  msg_body, _old_sig = msg_mod.rsplit("||SIG||", 1)

    (msg_body = "minha mensagem")

O servidor pode:
  - modificar msg_body (no seu exemplo, com "!upper", etc.)
  - deitar fora a assinatura original
  - assinar msg_body com a chave de impersonação:

    imp_priv = impersonation_keys["alice"]
    sig_fake = RSA_sign(imp_priv, msg_body)
    sig_b64  = base64(sig_fake)

  - reconstruir plaintext_out:

    plaintext_out = msg_body + "||SIG||" + sig_b64

Isto significa:
  - Mesmo que a Alice nunca tenha assinado "OLA BOB",
    o servidor pode reescrever a mensagem para
      "OLA BOB"
    e produzir uma assinatura válida usando sk_Server_as_Alice.

Depois S recifra:

  cipher_out = AES_CBC_Encrypt(k_enc, iv, plaintext_out)
  tag_out    = HMAC(k_mac, header || blob || iv || cipher_out)

Guarda na BD e depois:

S -> C2 envia:

  MSG_FROM alice header_b64 blob_b64 iv_b64 cipher_out_b64 tag_out_b64

(5.3) C2 recebe e verifica
--------------------------
C2 decifra a mensagem tal como antes:
  - usa as chaves DH K_enc, K_mac
  - verifica HMAC
  - decifra AES-CBC

Obtém:

  "minha mensagem||SIG||<sig_fake>"

No código do cliente em C2:
  - faz split em "||SIG||"
  - msg_part = "minha mensagem"
  - sig_b64  = "<sig_fake>"

Agora o passo crucial:

  - Para verificar, C2 precisa da chave pública da "Alice".
  - Tem de chamar /getpk alice primeiro.

(5.4) Substituição de chave via /getpk
--------------------------------------
Quando o Bob escreve:

  /getpk alice

C2 -> S envia:

  GET_PK alice

S NÃO envia pk_Alice_real.
Em vez disso, envia a chave pública correspondente à chave de impersonação:

  pub_for_peers = impersonation_keys["alice"].public_key()
  der_bytes = pub_for_peers.DER
  b64_pk    = base64(der_bytes)

S -> C2 envia:

  PK alice b64_pk

No C2, o cliente guarda:

  peer_pubkeys["alice"] = der_bytes

Portanto, quando C2 verifica uma assinatura "da Alice", usa:

  pk_Server_as_Alice (controlada pelo servidor).

(5.5) Resultado da verificação no C2
------------------------------------
Quando C2 verifica:

  RSA_verify(
    pk_Server_as_Alice,
    msg_part="minha mensagem",
    sig_fake
  )

Isto passa -> ASSIN_OK.

Então C2 imprime:

  FROM alice [cifrado+HMAC+ASSIN_OK]: minha mensagem

Mas na realidade:
  - A assinatura real da Alice (sig_real) foi descartada no servidor.
  - O servidor voltou a assinar a mensagem (possivelmente alterada) com a sua própria chave.
  - O cliente confia nesta chave forjada como sendo "a chave da Alice".

Este é o "RSA backdoor" em /send_signed:
  - Funciona substituindo a chave pública da Alice por uma chave falsa do servidor.
  - Depois forja assinaturas usando a chave privada correspondente.


--------------------------------------------------------------------------------
6. /history — O SERVIDOR LÊ TUDO USANDO O BACKDOOR
--------------------------------------------------------------------------------

Quando um cliente faz:

  /history Bob

O cliente C1 -> S envia:

  HISTORY bob [opções]

S vai à BD buscar as linhas:

  sender, recipient, ts, header_b64, blob_b64, iv_b64, cipher_b64, tag_b64

Para cada linha, S:

  - descodifica header, blob, iv, cipher, tag
  - recupera K_enc = AES_DEC_ECB(K_SERVER, blob)
  - k_mac = SHA256(K_enc)
  - verifica HMAC
  - decifra AES-CBC(K_enc, iv, cipher)
  - obtém o plaintext (com ou sem "||SIG||...")

Depois S imprime para o cliente que pediu o histórico:

  [timestamp] sender -> recipient: plaintext

Ou seja:
  - O servidor não só lê as mensagens em trânsito,
  - Como também consegue ler todas as mensagens passadas guardadas na BD,
    porque o blob backdoor permite reconstruir K_enc para
    cada mensagem armazenada.

Isto quebra completamente a confidencialidade, mesmo de sessões antigas.


--------------------------------------------------------------------------------
7. RESUMO: COMO FUNCIONAM OS BACKDOORS
--------------------------------------------------------------------------------

1) "Blob Backdoor" (/send)

   - As chaves de cifra (K_enc) não são verdadeiramente segredos efémeros.
   - São sempre "embrulhadas" sob K_SERVER com AES-ECB num campo chamado "blob".
   - Qualquer entidade com K_SERVER (o servidor malicioso) pode fazer:

       K_enc = AES_ECB_Decrypt(K_SERVER, blob)
       K_mac = SHA256(K_enc)

   - Isto permite ao servidor:
       * ler qualquer mensagem cifrada (/send ou /send_signed),
       * modificá-la,
       * recifrar e recomputar tags HMAC válidas.

   - Resultado: A cifra de ponta-a-ponta é uma ilusão.
     O servidor tem capacidades completas de MITM a nível simétrico.

2) "RSA Backdoor" (/send_signed + /getpk)

   - Cada utilizador tem um par de chaves RSA real no seu cliente.
   - Durante o /register, o servidor cria TAMBÉM um par de chaves RSA falso
     por utilizador (impersonation_keys[username]).

   - Quando outro cliente pede a chave pública de um utilizador via /getpk,
     o servidor devolve a chave pública desse par falso.

   - Quando /send_signed é usado:
       * O cliente assina com a sua chave privada real.
       * O servidor decifra, deita fora a assinatura original, altera a
         mensagem se quiser, e volta a assinar com a sua chave de impersonação.
       * O destinatário verifica usando a chave pública fornecida por /getpk,
         que afinal é a chave do servidor, por isso a verificação passa.

   - Resultado: As assinaturas digitais já não provam que foi a Alice a assinar.
     Só provam que "quem controla o servidor" assinou.

3) Efeito combinado

   - /send:
       * confidencialidade e integridade estão completamente sob controlo do servidor.

   - /send_signed:
       * confidencialidade quebrada via blob.
       * autenticidade quebrada via substituição de chaves públicas e chaves de
         impersonação.

   - /history:
       * todas as mensagens guardadas podem ser decifradas pelo servidor a qualquer
         momento.

   Este sistema:
     - mostra como primitivas criptográficas avançadas (DH, AES, HMAC, RSA, ZKP)
       podem ser tornadas inúteis se o protocolo ou a distribuição de chaves
       for desenhada de forma maliciosa.
     - demonstra um ataque clássico de key escrow / backdoor e
       de substituição de chaves públicas.


================================================================================
FIM DA EXPLICAÇÃO
================================================================================
