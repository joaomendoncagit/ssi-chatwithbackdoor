================================================================================
FULL STEP-BY-STEP EXPLANATION (C1 / S / C2) + BACKDOORS
================================================================================

Notation:
  C1 = client 1 (Alice)
  C2 = client 2 (Bob)
  S  = server (malicious / with backdoors)

Commands:
  /register     -> create user + upload public keys (RSA + Schnorr)
  /login        -> prove knowledge of password via Schnorr ZKP
  /dh_start     -> create DH session for symmetric encryption
  /send         -> encrypted message (AES-CBC + HMAC) but with a blob backdoor
  /send_signed  -> encrypted + signed message, but signatures are subverted

We go in the order things appear logically in your code.

--------------------------------------------------------------------------------
1. REGISTRATION PHASE (/register)
--------------------------------------------------------------------------------

(1.1) C1 generates local RSA keys
---------------------------------
C1 locally generates an RSA keypair:

  sk_Alice_real, pk_Alice_real = RSA.generate()

These are only on C1:
  - sk_Alice_real (private) is encrypted on disk with the password.
  - pk_Alice_real (public) is kept plaintext in alice_pub.pem.

(1.2) C1 derives Schnorr secret x
---------------------------------
C1 derives a Schnorr secret from username + password:

  username_norm = lower(username)
  x = H(username_norm || ":" || password) mod Q_SCHNORR

Then computes the Schnorr public key:

  y = g^x mod p

(1.3) C1 sends registration data to S
-------------------------------------
C1 -> S sends:

  REGISTER username password pk_Alice_real_DER_base64 y_base64

S receives:
  - username
  - password (not really used for auth here in final version)
  - pk_Alice_real (the "true" RSA public key from the client)
  - y (Schnorr public key for future ZKP login)

(1.4) S stores user + Schnorr key in DB
---------------------------------------
S stores in the database:

  - users table:
      username (lowercase)
      pubkey_b64 = pk_Alice_real_DER_base64

  - schnorr_users table:
      username (lowercase)
      y_b64 = Schnorr public key y (base64)

S also loads pk_Alice_real into memory:
  users[username] = pk_Alice_real_object


(1.5) S creates impersonation keypair for this user
---------------------------------------------------
Here is the "first big backdoor":

For each registered user, S generates his own RSA keypair:

  sk_Server_as_Alice, pk_Server_as_Alice = RSA.generate()

and stores:

  impersonation_keys["alice"] = sk_Server_as_Alice

This private key is only known by S.

This means:
  - S can produce signatures that will look like "Alice",
    as long as clients later use pk_Server_as_Alice to verify.

S -> C1 replies:

  OK REGISTER


--------------------------------------------------------------------------------
2. LOGIN PHASE (/login via Schnorr ZKP)
--------------------------------------------------------------------------------

(2.1) C1 computes Schnorr values r, t
-------------------------------------
C1 derives again:

  x = H(username_norm || ":" || password) mod Q

Then choose random r:

  r random in [1, Q-1]
  t = g^r mod p

C1 -> S sends:

  LOGIN_ZKP username t_b64

(2.2) S looks up Schnorr public key and sends challenge
-------------------------------------------------------
S does:

  y_b64 = fetch_schnorr_pub(username)
  y_int = decode(y_b64)  # from DB

S generates random challenge c:

  c_int random in [0, Q-1]
  (store (username, t, c, y) in pending_schnorr[conn])

S -> C1 sends:

  ZKP_CHALLENGE c_b64

(2.3) C1 computes response s
-----------------------------
C1 decodes c, then computes:

  s = r + c * x mod Q

C1 -> S sends:

  LOGIN_ZKP_RESP username s_b64

(2.4) S verifies Schnorr proof
------------------------------
S retrieves (username, t, c, y) from pending_schnorr.

Verifies:

  left  = g^s mod p
  right = t * y^c mod p

If left == right:
  - ZKP success
  - user is authenticated
  - S marks current_username = username
  - S adds (username -> socket) in online_clients

S -> C1 sends:

  OK LOGIN_ZKP

Additionally:
  - C1 locally decrypts its RSA private key with password
    and stores sk_Alice_real in memory to sign messages.

This ZKP login ensures:
  - S learns nothing about password x itself (beyond what it can brute force),
  - But S still controls everything else (keys, routing, backdoor, etc.).


--------------------------------------------------------------------------------
3. DIFFIE-HELLMAN PHASE (/dh_start)
--------------------------------------------------------------------------------

(3.1) C1 initiates DH with C2
-----------------------------
C1 generates an X25519 keypair:

  dh_priv_Alice, dh_pub_Alice = X25519.generate()

C1 stores:

  dh_sessions["bob"] = {
      "dh_priv": dh_priv_Alice,
      "shared": None,
      "k_enc": None,
      "k_mac": None
  }

C1 -> S sends:

  DH_INIT bob base64(dh_pub_Alice)

(3.2) S forwards DH_INIT to C2
------------------------------
S looks up dest "bob" in online_clients, then:

S -> C2 sends:

  DH_INIT_FROM alice base64(dh_pub_Alice)

(3.3) C2 responds with its DH public key
----------------------------------------
C2 on receiving DH_INIT_FROM:
  - generates dh_priv_Bob, dh_pub_Bob
  - computes shared secret:

      shared_B = dh_priv_Bob.exchange(dh_pub_Alice)

  - derives keys:

      K_enc = SHA256("enc" || shared)[0:16]
      K_mac = SHA256(K_enc)

  - stores in dh_sessions["alice"]:
      {
        "dh_priv": dh_priv_Bob,
        "shared": shared_B,
        "k_enc": K_enc,
        "k_mac": K_mac
      }

C2 -> S sends:

  DH_REPLY alice base64(dh_pub_Bob)

(3.4) S forwards DH_REPLY to C1
-------------------------------
S -> C1 sends:

  DH_REPLY_FROM bob base64(dh_pub_Bob)

C1 receives, computes:

  shared_A = dh_priv_Alice.exchange(dh_pub_Bob)

Then derives:

  K_enc = SHA256("enc" || shared_A)[0:16]
  K_mac = SHA256(K_enc)

Now both C1 and C2 share:
  - K_enc (AES key)
  - K_mac (HMAC key)

BUT the next step is crucial: the "blob" backdoor lets S recover K_enc.


--------------------------------------------------------------------------------
4. /send — ENCRYPTED MESSAGE WITH BLOB BACKDOOR
--------------------------------------------------------------------------------

(4.1) C1 builds encrypted packet
--------------------------------
When C1 calls:

  /send bob <message>

Client code:

  - header = "alice->bob".encode()
  - K_enc, K_mac from DH session
  - blob = AES_ECB_Encrypt(K_SERVER, K_enc)    # BACKDOOR!
  - iv   = blob[0:16]                          # uses part of blob as IV
  - cipher = AES_CBC_Encrypt(K_enc, iv, msg)
  - tag    = HMAC_SHA256(K_mac, header || blob || iv || cipher)

Then C1 -> S sends:

  MSG bob base64(header) base64(blob) base64(iv) base64(cipher) base64(tag)

(4.2) S uses blob to recover K_enc
----------------------------------
Server receives:

  (dest, header_b64, blob_b64, iv_b64, cipher_b64, tag_b64)

Decodes header, blob, iv, cipher, tag.

Backdoor step:

  k_enc = AES_ECB_Decrypt(K_SERVER, blob)
  k_mac = SHA256(k_enc)

S can now:
  - Recompute tag = HMAC_SHA256(k_mac, header || blob || iv || cipher)
  - Verify integrity (HMAC)
  - Decrypt:

      plaintext = AES_CBC_Decrypt(k_enc, iv, cipher)

So S sees all messages in cleartext, no matter what.

(4.3) S optionally modifies message
-----------------------------------
Your code has logic:

  msg_mod = plaintext_str
  if msg_mod.startswith("!upper "):
      msg_mod = msg_mod[len("!upper ") :].upper()

So S can modify the content before delivering it.
(This is a demo; in reality S could do anything.)

Then S re-encrypts:

  plaintext_out = msg_mod.encode()
  cipher_out    = AES_CBC_Encrypt(k_enc, iv, plaintext_out)
  tag_out       = HMAC(k_mac, header || blob || iv || cipher_out)

S -> C2 sends:

  MSG_FROM alice base64(header) base64(blob) base64(iv)
           base64(cipher_out) base64(tag_out)

(4.4) C2 decrypts & verifies
----------------------------
C2:
  - finds K_enc, K_mac from DH session (with "alice")
  - recomputes tag_calc = HMAC(K_mac, header || blob || iv || cipher)
  - if tag_calc == tag: message is authentic at symmetric layer
  - decrypts with AES-CBC(K_enc, iv, cipher)
  - prints plaintext

Result:
  - C2 thinks message is securely encrypted + authenticated between C1 and C2
  - In reality, S:
      * sees all plaintexts
      * can modify arbitrary messages
      * still passes all HMAC integrity checks (because S knows K_enc, K_mac)

This is the "blob backdoor" on /send.


--------------------------------------------------------------------------------
5. /send_signed — ENCRYPTED + SIGNED, BUT RSA IS ALSO BACKDOORED
--------------------------------------------------------------------------------

Goal of /send_signed:
  - C1: sign the message with its RSA private key (sk_Alice_real)
  - C2: verify with Alice's public key
  - Simulate end-to-end authenticity

In a normal secure system:
  - pk_Alice_real is distributed authentically.
  - No one except Alice has sk_Alice_real.
  - Server cannot forge Alice's signatures.

But here the server:
  - controls what public key C2 sees via /getpk
  - has its own fake private key sk_Server_as_Alice
  - re-signs messages with that key.

Let's see the flow.

(5.1) C1 signs and encrypts message
-----------------------------------
C1, when you do:

  /send_signed bob "my message"

The client:

  msg_bytes = b"my message"

  # 1. Sign with REAL Alice key
  sig_real = RSA_sign(sk_Alice_real, msg_bytes)

  b64_sig = base64(sig_real)

  # 2. Build plaintext with embedded signature
  plaintext = "my message||SIG||" + b64_sig

Then encrypts exactly like /send:

  - header = "alice->bob"
  - blob   = AES_ECB(K_SERVER, K_enc)
  - iv     = blob[0:16]
  - cipher = AES_CBC(K_enc, iv, plaintext)
  - tag    = HMAC(K_mac, header || blob || iv || cipher)

C1 -> S sends:

  MSG bob header_b64 blob_b64 iv_b64 cipher_b64 tag_b64

(5.2) S reads and possibly modifies the signed message
------------------------------------------------------
S decodes and uses blob backdoor to get K_enc, K_mac:

  k_enc = AES_ECB_Decrypt(K_SERVER, blob)
  k_mac = SHA256(k_enc)

Verifies HMAC, decrypts, obtains plaintext:

  plaintext = "my message||SIG||<base64(sig_real)>"

Now the "RSA backdoor" kicks in:

Your code checks if "||SIG||" in msg_mod. If it finds it:

  msg_body, _old_sig = msg_mod.rsplit("||SIG||", 1)

    (msg_body = "my message")

Server then:
  - may modify msg_body (e.g. you did "!upper" examples)
  - discards the original signature
  - signs msg_body with its own impersonation key:

    imp_priv = impersonation_keys["alice"]
    sig_fake = RSA_sign(imp_priv, msg_body)
    sig_b64  = base64(sig_fake)

  - rebuilds plaintext_out:

    plaintext_out = msg_body + "||SIG||" + sig_b64

This means:
  - Even if Alice never signed "HELLO BOB",
    the server can rewrite the message to
      "HELLO BOB"
    and produce a valid-looking signature using sk_Server_as_Alice.

Then S re-encrypts:

  cipher_out = AES_CBC_Encrypt(k_enc, iv, plaintext_out)
  tag_out    = HMAC(k_mac, header || blob || iv || cipher_out)

Stores to DB, then:

S -> C2 sends:

  MSG_FROM alice header_b64 blob_b64 iv_b64 cipher_out_b64 tag_out_b64

(5.3) C2 receives and verifies
------------------------------
C2 decrypts message exactly like before:
  - uses DH keys K_enc, K_mac
  - checks HMAC
  - decrypts AES-CBC

Gets:

  "my message||SIG||<sig_fake>"

Client code on C2:
  - splits at "||SIG||"
  - msg_part = "my message"
  - sig_b64  = "<sig_fake>"

Now crucial step:

  - To verify, C2 needs "Alice's" public key.
  - It must call /getpk alice first.

(5.4) Key substitution via /getpk
---------------------------------
When Bob types:

  /getpk alice

C2 -> S sends:

  GET_PK alice

S does NOT send pk_Alice_real.
Instead, S sends the public key corresponding to its own impersonation key:

  pub_for_peers = impersonation_keys["alice"].public_key()
  der_bytes = pub_for_peers.DER
  b64_pk    = base64(der_bytes)

S -> C2 sends:

  PK alice b64_pk

On C2, the client stores:

  peer_pubkeys["alice"] = der_bytes

So now, whenever C2 verifies a signature "from Alice", it uses:

  pk_Server_as_Alice (server-controlled).

(5.5) Verification result on C2
-------------------------------
When C2 verifies:

  RSA_verify(
    pk_Server_as_Alice,
    msg_part="my message",
    sig_fake
  )

It succeeds -> ASSIN_OK.

So C2 prints:

  FROM alice [cifrado+HMAC+ASSIN_OK]: my message

But in reality:
  - The real Alice signature (sig_real) was discarded at the server.
  - The server re-signed the message (possibly modified) with its own key.
  - The client trusts this forged key as "Alice’s" key.

This is the "RSA backdoor" in /send_signed:
  - Works by replacing the public key of Alice with a fake server key.
  - Then forging signatures using the matching private key.


--------------------------------------------------------------------------------
6. /history — SERVER READS ALL MESSAGES USING BACKDOOR
--------------------------------------------------------------------------------

When a client runs:

  /history Bob

Client C1 -> S sends:

  HISTORY bob [options]

S queries the DB for rows:

  sender, recipient, ts, header_b64, blob_b64, iv_b64, cipher_b64, tag_b64

For each row, S:

  - decodes header, blob, iv, cipher, tag
  - recovers K_enc = AES_DEC_ECB(K_SERVER, blob)
  - k_mac = SHA256(K_enc)
  - verifies HMAC
  - decrypts AES-CBC(K_enc, iv, cipher)
  - gets plaintext (with or without "||SIG||...")

Then S prints to the requesting client:

  [timestamp] sender -> recipient: plaintext

So:
  - The server not only reads messages in transit,
  - It can also read all past messages from the database,
    because the blob backdoor lets it reconstruct K_enc for
    every stored message.

This fully breaks confidentiality, even for old sessions.


--------------------------------------------------------------------------------
7. SUMMARY: HOW THE BACKDOORS WORK
--------------------------------------------------------------------------------

1) "Blob Backdoor" (/send)

   - Encryption keys (K_enc) are not truly ephemeral secrets.
   - They are always wrapped under K_SERVER using AES-ECB into "blob".
   - Anyone with K_SERVER (the malicious server) can do:

       K_enc = AES_ECB_Decrypt(K_SERVER, blob)
       K_mac = SHA256(K_enc)

   - This lets the server:
       * read any encrypted message (/send or /send_signed),
       * modify it,
       * re-encrypt and recompute valid HMAC tags.

   - Result: End-to-end encryption is an illusion.
     The server acts as a full MITM with symmetric keys.

2) "RSA Backdoor" (/send_signed + /getpk)

   - Each user has a real RSA keypair on their client machine.
   - During /register, the server ALSO creates a fake RSA keypair per user
     (impersonation_keys[username]).

   - When another client asks for a user's public key via /getpk,
     the server returns the public key of this fake keypair.

   - When /send_signed is used:
       * The client signs with its real private key.
       * The server decrypts, discards the real signature, optionally edits
         the message, and re-signs with its own private key (impersonation key).
       * The receiver verifies using the public key supplied by /getpk,
         which is the server's key, so verification passes.

   - Result: Digital signatures no longer prove that Alice signed anything.
     They only prove that "whoever controls the server" signed it.

3) Combined Effect

   - /send:
       * confidentiality and integrity are fully under server control.

   - /send_signed:
       * confidentiality broken via blob.
       * authenticity broken via public-key substitution and impersonation keys.

   - /history:
       * all stored messages can be decrypted by server at any time.

   This system:
     - shows how sophisticated crypto primitives (DH, AES, HMAC, RSA, ZKP)
       can be made meaningless if the protocol or key distribution
       is maliciously designed.
     - demonstrates classic key escrow / backdoor and
       public-key substitution attacks.


================================================================================
END OF EXPLANATION
================================================================================
